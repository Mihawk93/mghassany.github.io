---
title: "R Workshop"
author: "Mohamad Ghassany & Altay Ozaygen"
date: "2017-02-24"
output:
  html_document:
    toc: true
    toc_depth: 2
    theme: flatly
---

## Some `R` basics

### Basic Commands

`R` uses functions to perform operations. To run a function called `funcname`,we type `funcname(input1, input2)` , where the inputs (or arguments) `input1` and `input2` tell `R` how to run the function. A function can have any number of inputs. For example, to create a vector of numbers, we use the function `c()` (for *concatenate*).

```{r}
x <- c(1,3,2,5)
x
```

Note that the `>` is not part of the command; rather, it is printed by `R` to indicate that it is ready for another command to be entered. We can also save things using `=` rather than `<-`. Note that the answer in the code above is followed by `#ans>` while in the `R` console it is not.

```{r}
x = c(1,6,2)
x
y = c(1,4,3)
length(x)
length(y)
x+y
```

Hitting the *up arrow* multiple times will display the previous commands, which can then be edited. This is useful since one often wishes to repeat a similar command.

The `ls()` function allows us to look at a list of all of the objects, such `ls()` as data and functions, that we have saved so far. The `rm()` function can be used to delete any object that we don't want.

```{r}
ls()
rm(x)
ls()
```

### Vectors

```{r}

# A handy way of creating sequences is the operator :
# Sequence from 1 to 5
1:5

# Storing some vectors
vec <- c(-4.12, 0, 1.1, 1, 3, 4)
vec

# Entry-wise operations
vec + 1
vec^2

# If you want to access a position of a vector, use [position]
vec[6]

# You also can change elements
vec[2] <- -1
vec

# If you want to access all the elements except a position, use [-position]
vec[-2]

# Also with vectors as indexes
vec[1:2]

# And also
vec[-c(1, 2)]
```

```{block, type = 'rmdexercise'}
Do the following:

- Create the vector $x=(1, 7, 3, 4)$.
- Create the vector $y=(100, 99, 98, ..., 2, 1)$.
- Compute $x_3+y_4$ and $\cos(x_3) + \sin(x_2) e^{-y_2}$. (Answers: `100`, `-0.9899925`)
- Set $x_{3}=0$ and $y_{2}=-1$. Recompute the previous expressions. (Answers: `97`, `2.785875`)
- Index $y$ by $x+1$ and store it as `z`. What is the output? (Answer: `z` is `c(-1, 93, 100, 96)`)

```


### Matrices, data frames and lists

```{r}
# A matrix is an array of vectors
A <- matrix(1:4, nrow = 2, ncol = 2)
A

# Another matrix
B <- matrix(1:4, nrow = 2, ncol = 2, byrow = TRUE)
B

# Binding by rows or columns
rbind(1:3, 4:6)
cbind(1:3, 4:6)

# Entry-wise operations
A + 1
A * B

# Accessing elements
A[2, 1] # Element (2, 1)
A[1, ] # First row
A[, 2] # First column

# A data frame is a matrix with column names
# Useful when you have multiple variables
myDf <- data.frame(var1 = 1:2, var2 = 3:4)
myDf

# You can change names
names(myDf) <- c("newname1", "newname2")
myDf

# The nice thing is that you can access variables by its name with the $ operator
myDf$newname1

# And create new variables also (it has to be of the same
# length as the rest of variables)
myDf$myNewVariable <- c(0, 1)
myDf

# A list is a collection of arbitrary variables
myList <- list(vec = vec, A = A, myDf = myDf)

# Access elements by names
myList$vec
myList$A
myList$myDf

# Reveal the structure of an object
str(myList)
str(myDf)

# A less lengthy output
names(myList)
```

### Graphics

The `plot()` function is the primary way to plot data in `R` . For instance, `plot(x,y)` produces a scatterplot of the numbers in `x` versus the numbers in `y`. There are many additional options that can be passed in to the `plot()` function. For example, passing in the argument `xlab` will result in a label on the `x-axis`. To find out more information about the `plot()` function, type `?plot`.

```{r}
x=rnorm(100)
# The rnorm() function generates a vector of random normal variables,
# rnorm() with first argument n the sample size. Each time we call this
# function, we will get a different answer.
y=rnorm(100)
plot(x,y)

# with titles
plot(x,y,xlab="this is the x-axis",ylab="this is the y-axis",
main="Plot of X vs Y")
```


### Distributions

```{r}
# R allows to sample [r], compute density/probability mass [d],
# compute distribution function [p] and compute quantiles [q] for several
# continuous and discrete distributions. The format employed is [rdpq]name,
# where name stands for:
# - norm -> Normal
# - unif -> Uniform
# - exp -> Exponential
# - t -> Student's t
# - f -> Snedecor's F (Fisher)
# - chisq -> Chi squared
# - pois -> Poisson
# - binom -> Binomial
# More distributions: ?Distributions


# Sampling from a Normal - 100 random points from a N(0, 1)
rnorm(n = 10, mean = 0, sd = 1)

# If you want to have always the same result, set the seed of the random number
# generator
set.seed(45678)
rnorm(n = 10, mean = 0, sd = 1)

# Plotting the density of a N(0, 1) - the Gauss bell
x <- seq(-4, 4, l = 100)
y <- dnorm(x = x, mean = 0, sd = 1)
plot(x, y, type = "l")

# Plotting the distribution function of a N(0, 1)
x <- seq(-4, 4, l = 100)
y <- pnorm(q = x, mean = 0, sd = 1)
plot(x, y, type = "l", lwd = 3, main="The distribution function of a N(0, 1)")

# Computing the 95% quantile for a N(0, 1)
qnorm(p = 0.95, mean = 0, sd = 1)

# All distributions have the same syntax: rname(n,...), dname(x,...), dname(p,...)  
# and qname(p,...), but the parameters in ... change. Look them in ?Distributions
# For example, here is que same for the uniform distribution

# Sampling from a U(0, 1)
set.seed(45678)
runif(n = 10, min = 0, max = 1)

# Plotting the density of a U(0, 1)
x <- seq(-2, 2, l = 100)
y <- dunif(x = x, min = 0, max = 1)
plot(x, y, type = "l")

# Computing the 95% quantile for a U(0, 1)
qunif(p = 0.95, min = 0, max = 1)

```
```{block, type = 'rmdexercise'}
Do the following:

- Compute the 90%, 95% and 99% quantiles of a $F$ distribution with `df1 = 1` and `df2 = 5`. (Answer: `c(4.060420, 6.607891, 16.258177)`)
- Sample 100 points from a Poisson with `lambda = 5`.
- Plot the density of a $t$ distribution with `df = 1` (use a sequence spanning from `-4` to `4`). Add lines of different colors with the densities for `df = 5`, `df = 10`, `df = 50` and `df = 100`.
```

### Working directory

Your *working directory* is the folder on your computer in which you are currently working. When you ask R to open a certain file, it will look in the working directory for this file, and when you tell R to save a data file or figure, it will save it in the working directory.

To set your working directory within RStudio you can go to `Tools / Set working directory`, or use the command `setwd()`, we put the complete path of the directory between the brackets, do not forget to put the path into quotation marks `""`.

To know the actual working directory we use `getwd()`.


### Loading Data

The `read.table()` function is one of the primary ways to import a data set into `R`. The help file `?read.table()` contains details about how to use this function. We can use the function `write.table()` to export data.

Next we will show how to load the data set [`Auto.data`](datasets/Auto.data).

```{r echo=FALSE}
Auto=read.table("Auto.data",header=T,na.strings ="?")
```

```{r eval=FALSE}
Auto=read.table("Auto.data",header=T,na.strings ="?")
# For this file we needed to tell R that the first row is the
# names of the variables.
# na.strings tells R that any time it sees a particular character
# or set of characters (such as a question mark), it should be
# treated as a missing element of the data matrix. 
```

```{block, type = 'rmdinsight'}
- If the file is of csv format, we use `read.csv`. 
- Always try to look to the file before importing it to `R` (Open it in a text editor. See for example if the first row containes the variables names, if the columns are separated by `,` or `;` or ..
- For text editors, I suggest [`Sublime Text`](https://www.sublimetext.com/) or [`Atom`](https://atom.io/).
```

```{r}
dim(Auto) # To see the dimensions of the data set
nrow(Auto) # To see the number of rows
ncol(Auto) # To see the number of columns
Auto[1:4,] # The first 4 rows of the data set
```

```{r}
# Once the data are loaded correctly, we can use names()
# to check the variable names.
names(Auto)
```

```{block, type = 'rmdinsight'}
Take a look at this [(very) short introduction to R](https://cran.r-project.org/doc/contrib/Torfs+Brauer-Short-R-Intro.pdf). It can be useful.
```

## Regression

### The `lm` function

We are going to employ the `EU` dataset. The `EU` dataset contains 28 rows with the member states of the European Union (Country), the number of seats assigned under different years (Seats2011, Seats2014), the Cambridge Compromise apportionment (CamCom2011), and the countries population (Population2010,Population2013).

```{r echo=FALSE}
load("EU.RData")
```

```{r eval=FALSE}
# Load the dataset, when we load an .RData using load()
# function we do not attribute it to a name like we did
# when we used read.table() or when we use read.csv()

load("EU.RData")
```
```{block, type = 'rmdinsight'}

There is two ways to tell `R` where is the file you want to load/use/import or where to save a file when you write/export/save :

1. write the complete path of the files.
2. set a working directory and put the files in it.
```

```{r}
# lm (for linear model) has the syntax: 
# lm(formula = response ~ predictor, data = data)
# The response is the y in the model. The predictor is x.
# For example (after loading the EU dataset)
mod <- lm(formula = Seats2011 ~ Population2010, data = EU)

# We have saved the linear model into mod, which now contains all the output of lm
# You can see it by typing
mod

# mod is indeed a list of objects whose names are
names(mod)

# We can access these elements by $
# For example
mod$coefficients

# The residuals
mod$residuals

# The fitted values
mod$fitted.values

# Summary of the model
sumMod <- summary(mod)
sumMod
```


The following table contains a handy cheat sheet of equivalences between `R` code and some of the statistical concepts associated to linear regression.

|              `R`                       |        Statistical concept          |
|:---------------------------------------|:------------------------------------|
| `x` | Predictor $X_1,\ldots,X_n$    |
| `y` | Response $Y_1,\ldots,Y_n$    |
| `data <- data.frame(x = x, y = y)` | Sample $(X_1,Y_1),\ldots,(X_n,Y_n)$    |
| `model <- lm(y ~ x, data = data)` | Fitted linear model |
| `model$coefficients` | Fitted coefficients $\hat\beta_0,\hat\beta_1$ |
| `model$residuals` | Fitted residuals $\hat\varepsilon_1,\ldots,\hat\varepsilon_n$ |
| `model$fitted.values` | Fitted values $\hat Y_1,\ldots,\hat Y_n$ |
| `model$df.residual` | Degrees of freedom $n-2$ |
| `summaryModel <- summary(model)` | Summary of the fitted linear model |
| `summaryModel$sigma` | Fitted residual standard deviation $\hat\sigma$ |
| `summaryModel$r.squared` | Coefficient of determination $R^2$ |
| `summaryModel$fstatistic` | $F$-test |
| `anova(model)` | ANOVA table |

```{block, type = 'rmdexercise'}
Do the following:

- Download The 'EU' dataset from [here](datasets/EU.RData) as an `.RData` file and load it using the function `load`.
- Compute the regression of `CamCom2011` into `Population2010`. Save that model as the variable `myModel`.
- Access the objects `residuals` and `coefficients` of `myModel`.
- Compute the summary of `myModel` and store it as the variable `summaryMyModel`.
- Access the object `sigma` of `myModel`.
```

### Predicting House Value: Boston dataset

We are going to use a dataset called Boston which is part of the `MASS` package. It recordes the median value of houses for 506 neighborhoods around Boston. Our task is to predict the median house value (`medv`) using only one predictor (`lstat`: percent of households with low socioeconomic status).

```{r}
# First, install the MASS package using the command: install.packages("MASS")

# load MASS package
library(MASS)

# Check the dimensions of the Boston dataset
dim(Boston)
```

**STEP 1: Split the dataset**

```{r}
# Split the data by using the first 400 observations as the training
# data and the remaining as the testing data
train = 1:400
test = -train

# Speficy that we are going to use only two variables (lstat and medv)
variables = which(names(Boston) ==c("lstat", "medv"))
training_data = Boston[train, variables]
testing_data = Boston[test, variables]

# Check the dimensions of the new dataset
dim(training_data)
```

**STEP 2: Check for Linearity**

In order to perfom linear regression in `R`, we will use the function `lm()`to fit a simple linear regression with `medv` as the response (dependent variable) and `lstat` as the predictor or independent variable, and then save it in `model`.

But before we run our model, let’s visually check if the relationship between x and y is linear. 

```{r}
# Scatterplot of lstat vs. medv
plot(training_data$lstat, training_data$medv)
```

According to the plot, we see that the relationship is not linear. Let's try a transformation of our explanatory variable `lstat`.

```{r}
# Scatterplot of log(lstat) vs. medv
plot(log(training_data$lstat), training_data$medv)
```

Look at the plot, it is more linear, so we can proceed and perform `lm()`:

**STEP 3: Run the linear regression model**

```{r}
model = lm(medv ~ log(lstat), data = training_data)
model
```

Notice that basic information when we print `model`. This only give us the slope $(-12.2)$ and the intercept $(51.8)$ of the linear model. Note that here we are looking at `log(lstat)` and not `lstat` anymore. So for every one unit increase in `lstat`, the median value of the house will decrease by $e^{12.2}$. 
For more detailed information, we can use the `summary()` function:

```{r}
summary(model)
```

Now, we have access to p-values and standard errors for the coefficients, as well as the $R^2$. 

- The output states that the slope is statistically significant and different from $0$ and with a t-value= $-25.9$ (p-value $< 0.05$), which means that there is a significant relationship between the percentage of households with low socioeconomic income and the median house value. 
- This relationship is negative. That is as the percantage of household with low socioeconomic income increases, the median house value decreases. 
- Looking at $R^2$, we can deduce that $62.7\%$ of the model variation is being explained by the predictor `log(lstat)`. This is probably low, but indeed it would increase if we had more independent (explanatory) variables. We can use the `names()` function to see what other pieces of information are stored in our linear model (`model`). 

```{r}
names(model)
```

```{r}
model$coefficients
```

To obtain the confidence intervel for the linear model (`model`), we can use the `confint()` function:

```{r}
confint(model, level = 0.95)
```

So, a $95\%$ confidence interval for the slope of `log(lstat)` is $(-13.13, -11.28)$. Notice that this confidence interval gives us the same result as the hypothesis test performed earlier, by stating that we are $95\%$ confident that the slope of `lstat` is not zero (in fact it is less than zero, which means that the relationship is negative.) 


**STEP 4: Plot the regression model**

Now, let’s plot our regression line on top of our data.

```{r}
# Scatterplot of lstat vs. medv
plot(log(training_data$lstat), training_data$medv)

# Add the regression line to the existing scatterplot
abline(model)
```

Let’s play with the look of the plot, and makes it perttier!

```{r}
# Scatterplot of lstat vs. medv
plot(log(training_data$lstat), training_data$medv,
xlab = "Log Transform of % of Houshold with Low Socioeconomic Income",
ylab = "Median House Value",
col = "red",
pch = 20)

# Make the line color blue, and the line's width =3 (play with the width!)
abline(model, col = "blue", lwd =3)
```

**STEP 5: Assess the model**

Final thing we will do is to predict using our fitted model. We can use
the `predict()` function for this purpose:

```{r}
# Predict what is the median value of the house with lstat= 5%
predict(model, data.frame(lstat = c(5)))
```

```{r}
# Predict what is the median values of houses with lstat= 5%, 10%, and 15%
predict(model, data.frame(lstat = c(5,10,15), interval = "prediction"))
```

Now let's assess our model, by computing th mean squared error (MSE). To assess the model we created, then we will be using the test data!

```{r}
# Save the testing median values for houses (testing y) in y
y = testing_data$medv

# Compute the predicted value for this y (y hat)
y_hat = predict(model, data.frame(lstat = testing_data$lstat))

# Now we have both y and y_hat for our testing data. 
# let's find the mean square error
error = y-y_hat
error_squared = error^2
MSE = mean(error_squared)
MSE
```


<p class="text-right">&#9724;</p>
