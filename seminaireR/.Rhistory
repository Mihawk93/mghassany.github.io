# proposal
theta.1 <- runif(1)
# MH ratio
ratio<-(theta.1/theta.0)^y *((1 - theta.1)/(1 - theta.0))^(n-y)
if (runif(1) < ratio) {theta.0 <- theta.1}
theta.post <- c(theta.post,theta.0)
log.likelihood <- c(log.likelihood, y*log(theta.0) + (n-y)*log(1 - theta.0) )
}
# Check that the algorithm is correct
par(mfrow = c(1,3))
u <- seq(0, 1, length= 200)
plot(u, dbeta(u, 10, 12), type="n", ylab="Frequency", main="Posterior distribution (All sweeps)")
hist(theta.post, col = "blue" , prob = T, add = T)
lines(u, dbeta(u, 10, 12), col = 2, lwd = 3)
# shows the history
plot(log.likelihood[1:200], cex = .5, pch = 19, type = "l")
plot(u, dbeta(u, 10, 12), type="n", ylab="Frequency", main="Posterior distribution (100 sweeps)")
hist(theta.post[1:100], col = "blue" , prob = T, add = T)
lines(u, dbeta(u, 10, 12), col = 2, lwd = 3)
#Metropolis-Hastings
#kernel = non.uniform
nit = 10000
theta.0 <- 0.1
theta.post <- theta.0
log.likelihood <- NULL
for (i in 1:nit)
{
# proposal
b = 100
theta.1 <- rbeta(1, b*theta.0/(1-theta.0), b)
# MH ratio
ratio1 <- (theta.1/theta.0)^(y)*
( (1 - theta.1)/(1 - theta.0) )^(n-y)
ratio2 <-  dbeta(theta.0, b*theta.1/(1-theta.1), b)/
dbeta(theta.1, b*theta.0/(1-theta.0), b)
ratio <- ratio1*ratio2
if (runif(1) < ratio) {theta.0 <- theta.1}
theta.post <- c(theta.post,theta.0)
log.likelihood <- c(log.likelihood, y*log(theta.0) + (n-y)*log(1 - theta.0) )
}
# show results
u <- seq(0, 1, length= 200)
par(mfrow=c(1,3))
plot(u, dbeta(u, 10, 12), type="n", ylab="Frequency", main="Posterior distribution (burnin = 200)", xlab = "x")
hist(theta.post[200:5000], col = "blue" , prob = T, add = T)
lines(u, dbeta(u, 10, 12), col = 2, lwd = 3)
plot(u, dbeta(u, 10, 12), type="n", ylab="Frequency", main="150 sweeps", xlab = "x")
hist(theta.post[1:150], col = "yellow" , prob = T, add = T)
lines(u, dbeta(u, 10, 12), col = 2, lwd = 3)
plot(log.likelihood[1:100], cex = .5, pch = 19, type = "l")
#Metropolis-Hastings
#kernel = non.uniform
nit = 10000
theta.0 <- 0.1
theta.post <- theta.0
log.likelihood <- NULL
for (i in 1:nit)
{
# proposal
b = 100
theta.1 <- rbeta(1, b*theta.0/(1-theta.0), b)
# MH ratio
ratio1 <- (theta.1/theta.0)^(y)*
( (1 - theta.1)/(1 - theta.0) )^(n-y)
ratio2 <-  dbeta(theta.0, b*theta.1/(1-theta.1), b)/
dbeta(theta.1, b*theta.0/(1-theta.0), b)
ratio <- ratio1*ratio2
if (runif(1) < ratio) {theta.0 <- theta.1}
theta.post <- c(theta.post,theta.0)
log.likelihood <- c(log.likelihood, y*log(theta.0) + (n-y)*log(1 - theta.0) )
}
# show results
u <- seq(0, 1, length= 200)
par(mfrow=c(1,3))
plot(u, dbeta(u, 10, 12), type="n", ylab="Frequency", main="Posterior distribution (burnin = 200)", xlab = "x")
hist(theta.post[200:5000], col = "blue" , prob = T, add = T)
lines(u, dbeta(u, 10, 12), col = 2, lwd = 3)
plot(u, dbeta(u, 10, 12), type="n", ylab="Frequency", main="150 sweeps", xlab = "x")
hist(theta.post[1:150], col = "yellow" , prob = T, add = T)
lines(u, dbeta(u, 10, 12), col = 2, lwd = 3)
plot(log.likelihood[1:100], cex = .5, pch = 19, type = "l")
2*4
x=c(2,4,5)
?plot
mean(x)
install.packages("stats")
library(stats)
?"stats"
?plot
plot(cars)
lines(lowess(cars))
install.packages("swirl")
library(swirl)
swirl()
5+7
exit()
1-0.97725
0.93319-1+0.84134
0.5-4
-3.5/4
(0.80785+0.81057)/2
1-0.80921
?pnorm
pnorm(-0.875)
pnorm(0.5)
-1-4
-5/4
1.5-4
-2.5/4
(0.73237+1.73565)/2  + 0.89435
((0.73237+1.73565)/2)  + 0.89435
-((0.73237+1.73565)/2)  + 0.89435
-((0.73237+0.73565)/2)  + 0.89435
pnorm(1.25)- pnorm(0.625)
0.69146-1+0.99379
pnorm(0.5)-pnorm(-2.5)
0.5/0.93319
pnorm(0.5)
pnorm(0)
pnorm(0)/pnorm(1.5)
(1.0027+0.9986)/2
(19954)
(1.9954+2.0141)/2
x=1/3
(27+37+45)*x
mu=(27+37+45)*x
mu=(23+37+45)*x
mu
pop=c(23,37,45)
mean(pop)
var(pop)
sqrt(124)
mean(23,37)
(23+37)/2
(23+45)/2
(37+45)/2
mean(c(23,30,30,34,34,37,41,41,45))
var(c(23,30,30,34,34,37,41,41,45))
124/2
var(c(23,37,45))
29.5/2
var(c(23,30,30,34,34,37,41,41,45))
?var
124/3
x=1/9
x*(23-35)^2 + 2*x*(30-35)^2 + 2*x*(34-35)^2 + x*(37-35)^2 + 2*x*(41-35)^2+x*(45-35)^2
mean(c(23,37,45))
var(c(23,37,45))
mean(c(23,30,30,34,34,37,41,41,45))
var(c(23,30,30,34,34,37,41,41,45))
124/41.333
var(c(7,11.5,11.5,13.5,13.5,16,18,18,20))
var(c(7,16,20))
mean(c(7,16,20))
x=1/3
x*(7-14.3333)^2+x*(16-14.3333)^2 x*(20-14.3333)^2
x*(7-14.3333)^2+x*(16-14.3333)^2 +x*(20-14.3333)^2
x=1/3
x*(23-35)^2+x*(37-35)^2+x*(45-35)^2
var(c(7,11.5,11.5,13.5,13.5,16,18,18,20))
mean(c(7,16,20))
var(c(7,16,20))
44.33333/16.625
x*(23-35)^2 + 2*x*(30-35)^2 + 2*x*(34-35)^2 + x*(37-35)^2 + 2*x*(41-35)^2+x*(45-35)^2
x
x=1/9
x
x*(23-35)^2 + 2*x*(30-35)^2 + 2*x*(34-35)^2 + x*(37-35)^2 + 2*x*(41-35)^2+x*(45-35)^2
x*(23-35)^2+x*(37-35)^2+x*(45-35)^2
x=1/3
x*(23-35)^2+x*(37-35)^2+x*(45-35)^2
var
myvar = function(v) {
m = mean(v)
mean((m - v)^2)
}
var(c(23,30,30,34,34,37,41,41,45))
myvar(c(23,30,30,34,34,37,41,41,45))
mean(c(23,37,45))
var(c(23,37,45))
myvar(c(23,37,45))
var(c(23,30,30,34,34,37,41,41,45))
x*(23-35)^2 + 2*x*(30-35)^2 + 2*x*(34-35)^2 + x*(37-35)^2 + 2*x*(41-35)^2+x*(45-35)^2
x=1/8
x*(23-35)^2 + 2*x*(30-35)^2 + 2*x*(34-35)^2 + x*(37-35)^2 + 2*x*(41-35)^2+x*(45-35)^2
var(c(23,30,30,34,34,37,41,41,45))
sigma=0.02
mu=0.5
n=1000
00.2/(sigma*sqrt(2/n))
2/(sigma*sqrt(2/n))
?pnorm
pnorm(223.6068)
leaflet(df)
map('state', plot = TRUE, fill = FALSE, col = palette())
title("Crimes")
points(x=crime$longitude,y=crime$latitude,col='red',cex=0.75)
crime$size <- "small"  #create a column indicating size of marker
crime$col <- "red"   #create a column indicating color of marker
crime$char <- ""   #normal Google Maps pinpoints will be drawn
mymarkers <- cbind.data.frame(crime$latitude, crime$longitude, crime$size, crime$col, crime$char)   #create the data frame by binding my data columns of GPS coordinates with the newly created columns
names(mymarkers) <- c("lat", "lon", "size", "col", "char")  #assign column headings
lat <- c(48,60)  #now we are plotting the map
lon <- c(-140,-110)
terrain_close <- GetMap.bbox(lonR= range(lon), latR= range(lat), center= c(49.7, -121.05), destfile= "terrclose.png", markers= mymarkers, zoom=13, maptype="terrain")
3556-2404
1152/(6*2404)
34700/12
0.08*34700
2891*6
0.08*17346
3556-2404
1152/(2404*6)
1152/(2404*8)
1152/(2404*12)
(15+1.25)*45 + 6*52
1043+3556
4599+3200
pnorm(2)
pnorm(2)*2
2*0.9772
library(leaflet)
pal <- colorQuantile("YlOrRd", NULL, n = 8)
leaflet(orstationc) %>%
addTiles() %>%
addCircleMarkers(color = ~pal(tann))
m <- leaflet() %>%
addTiles() %>%  # Add default OpenStreetMap map tiles
addMarkers(lng=174.768, lat=-36.852, popup="The birthplace of R")
m
getwd()
library(leaflet)
m <- leaflet() %>%
+     addTiles() %>%  # Add default OpenStreetMap map tiles
+     addMarkers(lng=174.768, lat=-36.852, popup="The birthplace of R")
m
pal <- colorQuantile("YlOrRd", NULL, n = 8)
pal <- leaflet(orstationc)
pal <-   addTiles()
pal <-   addCircleMarkers(color = ~pal(tann))
```
library(maps)
orstationc <- read.csv("orstationc.csv")
orstationc <- read.csv("C:/Users/Ghassany/Desktop/orstationc.csv")
pal <- leaflet(orstationc)
pal <-   addTiles()
pal <-   addCircleMarkers(color = ~pal(tann))
orstationc <- read.csv("C:/Users/Ghassany/Desktop/orstationc.csv")
pal <- leaflet(orstationc)
pal <-   addTiles(pal)
pal <-   addCircleMarkers(pal,color = ~pal(tann))
pal <-   addCircleMarkers(color = ~pal(tann))
for (i in seq(1,50,5)){curve(dt(x,i),add=T,xlim = c(-2,+2), ylim=c(0,0.5))
curve(dnorm(x), add=T, col="red")}
question2=function(ech,alpha)
{
xbarre=mean(ech)
sd=sqrt(var(ech))
n=length(ech)
t=qt(1-alpha/2,n-1)
IC=list("[",xbarre-t*sd/sqrt(n),xbarre+t*sd/sqrt(n),"]")
print(IC)
}
question2(c(1,5,6,7,8,9,10,25),0.05)
question3=function(ech,sigma,alpha)
{
xbarre=mean(ech)
z=qnorm(1-alpha/2)
n=length(ech)
IC=list("[",xbarre-z*sigma/sqrt(n),xbarre+z*sigma/sqrt(n),"]")
print(IC)
}
question3(c(1,5,6,7,8,9,10,25),4,0.05)
question3(c(2.20,2.24,2.26,2.30,2.36,2.39,2.42,2.48,2.50,2.54),0.01,0.05)
# Application de la fonction question2 a l'exemple P.38
question2(c(2.20,2.24,2.26,2.30,2.36,2.39,2.42,2.48,2.50,2.54),0.05)
ech=rnorm(n=20,mean=2.5,sd=3)
#ech
mean(ech)
question2(ech,0.05)
question3(ech,3,0.05)
Imin3=rep(0,100)
for (i in seq(1,100)){
xbarre=mean(ech)
z=qnorm(1-(i/100)/2)
n=length(ech)
Imin3[i]=xbarre-z*3/sqrt(n)
}
Imin3
Imax3=rep(0,100)
for (i in seq(1,100)){
xbarre=mean(ech)
z=qnorm(1-(i/100)/2)
n=length(ech)
Imax3[i]=xbarre+z*3/sqrt(n)
}
Imax3
# Sigma inconnu
Imin2=rep(0,100)
for (i in seq(1,100)){
xbarre=mean(ech)
sd=sqrt(var(ech))
n=length(ech)
t=qt(1-(i/100)/2,n-1)
Imin2[i]=xbarre-t*sd/sqrt(n)
}
Imin2
Imax2=rep(0,100)
for (i in seq(1,100)){
xbarre=mean(ech)
sd=sqrt(var(ech))
n=length(ech)
t=qt(1-(i/100)/2,n-1)
Imax2[i]=xbarre+t*sd/sqrt(n)
}
alpha=rep(0,100)
for (i in seq(1,100)){
alpha[i]=i/100
}
alpha
plot(alpha, Imin3, type = "n", ylim = range(c(Imin3, Imax3)), xlab = "alpha", ylab = "ICMin ICMax")
lines(alpha, Imin3, col = "blue")
lines(alpha, Imax3, col = "red")
legend(0.8, 4.5, legend=c("ICmin", "ICmax"),
col=c("blue", "red"), lty=1:1, cex=0.8)
lines(x=c(0,1),y=c(2.5,2.5))
n=100
# Nombre d'échantillons
J=200
# Espérance de X
mu=2
# Ecart-type de X
s=1
# niveau de confiance 1-alpha
alpha=0.10
R=matrix(rnorm(J*n,mu,s),nrow=n,ncol=J)
#R
Xmean=matrix(0,1,J)
Xmean
for (j in 1:J){Xmean[j]=mean(R[,j])}
Xmean
Xecarttype=matrix(0,1,J)
Xecarttype
for (j in 1:J){
Xecarttype[j]=sqrt(var(R[,j]))}
Xecarttype
marge=qnorm(1-alpha/2)*s/sqrt(n)
marge
Imin=Xmean-marge
Imin
Imax=Xmean+marge
Imax
I=(mu>Imin)*(mu<Imax)
I
N=sum(I)
N
p=N/J
p
alpha=0.05
R=matrix(rnorm(J*n,mu,s),nrow=n,ncol=J)
#R
Xmean=matrix(0,1,J)
Xmean
for (j in 1:J){Xmean[j]=mean(R[,j])}
Xmean
Xecarttype=matrix(0,1,J)
Xecarttype
for (j in 1:J){
Xecarttype[j]=sqrt(var(R[,j]))}
Xecarttype
marge=qnorm(1-alpha/2)*s/sqrt(n)
marge
Imin=Xmean-marge
Imin
Imax=Xmean+marge
Imax
I=(mu>Imin)*(mu<Imax)
I
N=sum(I)
N
p=N/J
p
![](C:\Users\Ghassany\Desktop\Radarly_pics\limitation.png) Les informations sur le compte personnel **Instagram** n'apparaissent pas.
test <- read.csv("C:/Users/Ghassany/Desktop/blog-cuisine-comments/blogs-cuisine-comments.csv")
View(test)
str(test)
test <- read.csv("C:/Users/Ghassany/Desktop/blog-cuisine-comments/blogs-cuisine-comments.csv", fileEncoding = "UTF-8")
test <- read.csv("C:/Users/Ghassany/Desktop/blog-cuisine-comments/blogs-cuisine-comments.csv", fileEncoding = "UTF-8-BOM")
View(test)
test <- read.csv("C:/Users/Ghassany/Desktop/blog-cuisine-comments/blogs-cuisine-comments.csv", fileEncoding = "UTF-8-BOM")
34700/12
2891.667/2400
2400/2891
34700*0.83
28801/12
37000*0.83
30710/12
library(swirl)
install.packages("swirlify")
install.packages("swirlify")
swirl()
library(swirl)
swirl()
select_language(francais)
select_language(French)
select_language("French")
?select_language
select_language("french")
swirl()
1:20
q()
library(swirl)
library(swirlify)
swirlify("Lesson 1", "My Course")
x <- 5
y<- 10
x <- 1:20
y <- 1:20
plot(x,y)
library(swirl)
swirl()
swirl()
swirl()
pi:10
exit()
quit()
library(swirl)
swirl()
remove.packages("swirl")
library(swir)
library(swirl)
install.packages("swirl")
library(swirl)
swirl()
remove.packages("swirl")
x <- 10
y <- 5
x/y
x <- 1:20
install.packages("swirl")
library(swirl)
swirl()
knitr::opts_chunk$set(echo = FALSE)
knitr::opts_chunk$set(warnings = FALSE)
knitr::opts_chunk$set(message  = FALSE)
knitr::opts_chunk$set(comment=NA)
require(ggplot2)
# require(ggrepel) #text labels overlap each other in plots created with geom_text:
library(pander)
require(plotly)
require(data.table)
require(zoo) #pour utiliser zoo pour les dates (ajouter des dates oÃ¹ frequence est nulle)
require(reshape2) #pour utiliser melt pour afficher geom_plot tous les variables
# require(bit64) # fread from data.table asked for it
panderOptions("digits", 3)
panderOptions("table.style", 'simple')
#panderOptions("table.split.table", Inf)
#knitr::opts_knit$set(root.dir = '/home/ghassany/Desktop/Radarly_data/')
# rmarkdown::render('/home/ghassany/Dropbox/TEM/CuratedMedia/Rapports_CuratedMedia/Vayatis5.6.Rmd')
require(quantmod)
Banque_clusters <- read.csv("/media/ghassany/ssd/Radarly_data_clusters/Banque/Banque_clusters_gt20.csv",sep=",",fileEncoding = "UTF-8",header=T)
Banque_clusters <- read.csv("../Dropbox/TEM/CuratedMedia/Radarly_data_clusters/Banque_clusters_gt20.csv", sep = ",", header=T, fileEncoding = "UTF-8")
Banque_clusters <- read.csv("/media/ghassany/ssd/Radarly_data_clusters/Banque/Banque_clusters_gt20.csv",sep=",",fileEncoding = "UTF-8",header=T)
8*50
400/12
View(Banque_clusters)
install.packages("swirlify")
install.packages("swirl")
library(swirlify)
swirlify("Lesson 1", "My Course")
swirl()
library(swirl)
swirlify("Lesson 1", "My Course")
swirlify("Lesson 1", "My Course")
install.packages("devtools")
devtools::install_github("rstudio/bookdown")
knitr::opts_chunk$set(echo = FALSE)
knitr::opts_chunk$set(warnings = FALSE)
knitr::opts_chunk$set(message  = FALSE)
knitr::opts_chunk$set(comment=NA)
require(ggplot2)
# require(ggrepel) #text labels overlap each other in plots created with geom_text:
library(pander)
# require(plotly)
require(data.table)
require(zoo) #pour utiliser zoo pour les dates (ajouter des dates oÃ¹ frequence est nulle)
require(reshape2) #pour utiliser melt pour afficher geom_plot tous les variables
# require(bit64) # fread from data.table asked for it
panderOptions("digits", 3)
panderOptions("table.style", 'simple')
#panderOptions("table.split.table", Inf)
#knitr::opts_knit$set(root.dir = '/home/ghassany/Desktop/Radarly_data/')
# rmarkdown::render('/home/ghassany/Dropbox/TEM/CuratedMedia/Rapports_CuratedMedia/Vayatis5.6.Rmd')
require(quantmod)
install.packages("pander")
install.packages("data.table")
install.packages(c("plyr","zoo","reshape2","quantmod"))
install.packages("ggplot2")
install.packages("corrplot")
1/(sqrt(2*pi))
sqrt(10*0.7*0.3)
50*0.7
sqrt(50*0.7*0.3)
20*0.7
sqrt(14*0.7*0.3)
30*0.7
sqrt(20*0.7*0.3)
sqrt(30*0.7*0.3)
50*0.7
sqrt(50*0.7*0.3)
11.5*60+4*9*40+10*40
setwd("C:/Users/Ghassany/Dropbox/TEM/seminaire_R")
